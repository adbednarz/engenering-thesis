\chapter{Bot}
\thispagestyle{chapterBeginStyle}

W ostatnim rozdziale przedstawiono analizę złożoności gry Rummikub oraz jakie podejścia zostały zrealizowane do implementacji bota . Podczas rozważania złożoności gry oraz implementacji skorzystano z artykułu ,,The Complexity of Rummikub Problems'' \cite{RummikubComplexity}. W związku z zastosowaniem architektury trójwarstwowej po stronie klienta bot zastępuje  warstwę danych bez konieczności modyfikowania logiki aplikacji.

\section{Podstawowy bot}

Implementacja podstawowego bota miała na celu umożliwienie przeprowadzanie rozgrywek na niskim poziomie trudności. Jest on przeznaczony dla osób, które dopiero poznają grę Rummikub. Jego zasada działania polega na formowaniu serii oraz grup z własnego zbioru kości. Bot ponadto potrafi modyfikować zbiory znajdujące się na planszy poprzez dodanie swoich kości na początek lub na koniec danego zbioru.

\section{Złożoność gry}

Gra Rummikub składa się z 106 kości, w których są dwa jokery. Joker może reprezentować sobą dowolną inną kość. Zatem 104 kości są numerowane od 1 do 13, w czterech różnych kolorach i każda kość występuje dwa razy. Kości można grupować w sekcje (rosnący ciąg liczb o tym samym kolorze) lub w grupy (kości o takiej samej liczbie z różnymi kolorami). Problemem jest znalezienie najlepszego wyłożenia podczas danego ruchu. \\

 Liczbę sposobów ułożenia grup z danej puli kości oznaczono jako $G(k, m)$, gdzie $k$ to jest liczba kolorów, a $m$ to jest liczba kopii. Na początek wzięto pod rozważanie przypadek, gdy $k = 4$, a $m = 1$. W takim przypadku dla danej wartości kości można nie formować żadnej grupy, formować cztery grupy o długości trzy lub jedną o długości cztery. Zatem $G(4,1) = 1 + {{4}\choose{3}} + 1 = 6$. W przypadku, gdy $m = 2$ pojawia się kopia każdej kości, a zatem są dwa zestawy, dla których można policzyć $G(4,1)$. Czyli $G(4,2) < G(4,1)^2$. Jest to górna granica, ponieważ pewne przypadki zostaną policzone więcej niż raz. Podczas tworzenia grup nie bierze się pod uwagę kolejności w jakiej te grupy są tworzone oraz przypadki, które łącznie dają taki sam zbiór kości, nie powinny być rozróżnialne. Pomimo tego liczba możliwych sposobów utworzenia grup rośnie nadal wykładniczo powołując się na artykuł \cite{RummikubComplexity}. Z tego powodu w implementacji algorytmu na początku formuje się serie, a dopiero później grupy z pozostałych kości. \\

Wybierając podejście, w którym najpierw formułuje się serie, a później grupy, dzieli się zbiór wszystkich kości (plansza oraz kości gracza) ze względu na wartość danej kości. Dla każdego podzbioru w kolejności od kości o wartościach $1$ aż do wartości $13$ tworzy się wszystkie możliwe kombinacje użycia poszczególnych kości do danych serii. Natomiast z kości, które pozostały w podzbiorach tworzy się możliwie jak największe grupy. \\

Zatem wystarczy dla każdego podzbioru o danej wartości kości, zdefiniować wszystkie możliwe do uzyskania konfiguracje serii. Aby seria spełniała zasady gry musi mieć co najmniej długość $3$. Z tego powodu poszczególne serie koduje się za pomocą cyfr $0$, $1$, $2$, $3$.  Wszystkie serie o długości powyżej $3$ koduje się jako $(3)$ w celu optymalizacji liczebności serii. Poszczególny stan gry będzie przedstawiony w postaci \emph{[wartość, konfiguracje serii]}. \\

W grze Rummikub jest możliwe stworzenie ośmiu pełnych serii (zbiór kości 1-13). Z tego powodu, że występują cztery kolory oraz każda kość ma swoją kopię. Zatem stan gry będzie określony jako $[v, abcdefgh]$, gdzie $v \in \{1..13\}$, a $(a, b, c, d, e, f, g, h) \in \{0, 1, 2, 3\}$. Założono, że $(a, b)$ przedstawiają serie koloru czarnego, $(c, d)$ koloru niebieskiego, $(e, f)$ koloru pomarańczowego, $(g, h)$ koloru czerwonego. Serie kości $(2, 3, 4, 5)$ koloru niebieskiego oraz $(1, 2, 3)$ koloru czerwonego będą zakodowane w następujący sposób: $$[1, 00000001], [2, 00010002], [3, 00020003], [4, 00030000], [5, 00030000], [6, 00000000]$$

\section{Zaawansowany bot}

Podczas implementacji bota zmodyfikowano algorytm opisany w artykule \cite{RummikubComplexity}. $MaxScore$ oprócz zwracania największej możliwej sumy wszystkich wartości kości, zwraca również wybraną konfiguracje serii oraz gwarantuje, że wszystkie kości na planszy będą ponownie wykorzystane. \\

\begin{pseudokod}[H]
	\SetAlTitleFnt{small}
	\SetArgSty{normalfont}
	\SetKwFunction{MakeRuns}{MakeRuns}
	\SetKwFunction{GetRunScores}{GetRunScores}
	\SetKwFunction{GetGroupScores}{GetGroupScores}
	\SetKwFunction{MaxScore}{MaxScore}
	\KwIn{$value, runs, tableTiles$}
	\KwOut{$result[value, runs]$}
	\vskip 1mm
	\If{$value > 13$}{
		\textbf{return} $null$;
	}
	\If{$result[value, runs] \neq null$}{
		\textbf{return} $result[value, runs]$;
	}
	$scores \leftarrow -\infty$\;
	\For{$possibleRuns \in \MakeRuns{value, runs}$}{
		$runScores \leftarrow \GetRunScores{possibleRuns, runs, tableTiles, tiles, value}$\;
		$groupScores \leftarrow \GetGroupScores{tiles, value}$\;
		\If{$runScores = -1$ or $groupScores = -1$}{
			\textbf{continue};
		}
		$maxScore \leftarrow \MaxScore{value + 1, possibleRuns, tableTiles}$\;
		$sum \leftarrow runScores + groupScores + maxScore[scores]$\;
		\If{$scores < sum$}{
			$scores \leftarrow sum$\;
			$result[value, runs] \leftarrow [sum, possibleRuns]$\;	
		}
	}
	\caption{MaxScore}\label{alg:mine}
\end{pseudokod}
\vskip 3mm

Na początku algorytmu sprawdzane jest czy dana wartość $value$ nie przekroczyła maksymalnej wartości kości oraz czy dany stan gry nie został już poprzednio obliczony. Następnie następuje iteracja po wszystkich możliwych nowych konfiguracjach serii. Funkcja $MakeRuns$ tworzy nowe konfiguracje na podstawie obecnej konfiguracji serii i dostępnych kościach o wartości $value$. Funkcja $GetRunScores$ oblicza punkty na podstawie porównania nowej konfiguracji $possibleRuns$ z poprzednią $runs$. Ponadto usuwa ze zbioru $tiles$, użyte kości do utworzenia nowej konfiguracji serii. W przypadku gdyby seria o długości mniejszej niż trzy zawierające kości należące do planszy zostałaby przerwana, $GetRunScores$ zwróci wartość $-1$. $GetGroupScores$ z kolei tworzy grupy o największej liczbie punktów, usuwa użyte kości ze zbioru $tiles$ i w przypadku gdy pozostaną kości należące do planszy również zwraca $-1$. Następnie jest wywoływana rekurencyjnie funkcja $MaxScore$, której przekazywana wartość kości powiększona o jeden, nowa konfiguracja kości oraz zmodyfikowana tablica $tableTiles$. Po zsumowaniu wyniku sprawdzane jest, czy otrzymywany wynik jest obecnie największym możliwym wynikiem dla tego stanu gry.
Najlepszy wynik otrzymany w poszczególnym stanie jest zapisywany do tablicy wszystkich stanów wraz z konfiguracją serii, która została wybrana dla tego stanu. \\

Po wykonanej rekurencji algorytm zwraca najlepszy możliwy wynik oraz pierwszą wybraną konfigurację serii. Dzięki temu, że dla każdej wartości $value$ wynik jest zapisywany do tablicy $result$ z indeksem $[value, runs]$ można odtworzyć przebieg konfiguracji serii. Zatem iterując po wszystkich wartościach $value$ można odtworzyć utworzone serie oraz grupy.



