\chapter{Implementacja serwisu}
\thispagestyle{chapterBeginStyle}

\section{Serwer}

Przy implementacji serwera wykorzystano głównie trzy moduły Firebase takie jak uwierzytelnianie, firestore (baza danych NoSQL) oraz funkcje. Jako metodę rejestracji użytkownika wybrano opcję weryfikacji za pomocą adresu email. Komunikacja pomiędzy serwerem, a klientem opiera się na dwóch sposobach. Klient może bezpośrednio nasłuchiwać zmian zachodzących w bazie danych Firestore, albo wywoływać funkcje Firebase.

\subsection{Baza danych}

W bazie danych czasu rzeczywistego Firestore zostały umieszczone dwie kolekcje - \emph{Users}, \emph{Games}. \\

W kolekcji \emph{Users} są przechowywane dokumenty indeksowane unikatowymi kodami ID użytkownika, które są przydzielane w czasie rejestracji. Każdy dokument zawiera pola \emph{name} i \emph{active}. Pole \emph{name} odnosi się do nazwy użytkownika, a pole \emph{active} jest wartością logiczną wskazującą, czy dany użytkownik jest dostępny w grze (jest zalogowany i obecnie nie znajduje się w rozgrywce z innymi graczami). Opcjonalne pole \emph{invitation} jest mapą zawierającą klucze \emph{gameId} oraz \emph{player}, których wartości wskazują kolejno na kod ID gry i nazwę gracza, który zaprosił danego gracza do swojej gry. \\

W kolekcji \emph{Games} są przechowywane dokumenty indeksowane automatycznie generowanymi unikatowymi kodami ID przy tworzeniu dokumentu i które są przypisane jako kody ID gier. Każdy dokument zawiera trzy pola: \emph{available} (wskazuje ile graczy może jeszcze dołączyć do gry), \emph{currentTurn} (wskazuje jakiego gracza jest teraz kolej), \emph{size} (wskazuje na liczbę graczy w grze). Ponadto dokument danej gry zawiera jeszcze subkolekcje \emph{playersQueue}, \emph{playersRacks}, \emph{pool}, \emph{state}. \\ \\
Subkolekcja \emph{playersQueue} jest to zbiór dokumentów indeksowanych kodami ID graczy, którzy uczestniczą w tej grze. Każdy dokument zawiera pole \emph{name} z nazwą gracza oraz pole \emph{initialMeld}, które wskazuje czy dany gracz wyłożył już rozdanie początkowe. \\
Subkolekcja \emph{playersRack} to zbiór dokumentów z automatycznie generowanymi kodami ID. Dokumenty te przedstawiają kości, które są przydzielone graczowi. Każdy dokument zawiera dwa pola \emph{color} oraz \emph{number}. \\ \\
Subkolekcja \emph{pool} to z kolei zbiór dokumentów z automatycznie generowanymi kodami ID. Zbiór tych dokumentów przedstawia bank w grze, czyli wszystkie kości, które nie znajdują się na planszy ani nie są przydzielone do gracza. Każdy dokument ma pola \emph{color} oraz \emph{number}. \\ \\
Subkolekcja \emph{state} zawiera dokładnie jeden dokument \emph{sets} o najbardziej złożonej strukturze. W dokumencie \emph{sets} znajdują się wszystkie zbiory, które są wyłożone na planszy. Struktura tego dokumentu składa się z mapy, w której klucze to pozycja pierwszej kości z danego zbioru na planszy, a więc moment, w którym rozpoczyna się dany zbiór kości. Wartości tej mapy to tablica kości, gdzie każda kość jest w postaci mapy z kluczami \emph{color} i \emph{number}. Taki sposób przedstawienia stanu planszy wynika głównie z optymizacji kosztów modyfikowania bazy danych. Nie rozbito każdego zbioru kości na osobne dokumenty, ponieważ zwiększa to nam liczbę zliczanych zapisów do bazy danych. Ponadto w tym przypadku nie ma potrzeby korzystania z właściwości oferowanych przez dokumenty takie jak śledzenie zmian w danym dokumencie czy możliwość tworzenia prostych zapytań SQL na zbiorze dokumentów.

\subsection{Uwierzytelnianie}

Tak jak wspomniano wyżej występują dwa sposoby komunikacji klienta z serwerem. W przypadku funkcji Firebase do zapytań HTTPS z aplikacji, automatycznie są dołączane tokeny uwierzytelniania. W przypadku nasłuchiwaniu zmian zachodzących w bazie danych lub operacjach zaczytywania i modyfikowania bazy danych Firestore za proces autoryzacji dostępu są odpowiedzialne reguły bezpieczeństwa Firestore. \\
W tym projekcie reguły bezpieczeństwa Firestore są zdefiniowane następująco:
\begin{itemize}
	\item w kolekcji \emph{users} użytkownik ma dostęp jedynie do dokumentu z własnym ID, na którym może wykonywać operacje czytania i modyfikacji,
	\item w kolekcji \emph{games} użytkownik ma dostęp jedynie do dokumentu gry, w którym on sam jest jednym z graczy. W tym dokumencie będzie miał dostęp do pól zdefiniowanych w dokumencie oraz do subkolekcji \emph{playersQueue} oraz \emph{playersRacks}. Co więcej w \emph{playersRacks} będzie miał dostęp jedynie do dokumentu z własnym polem ID. We wszystkich dostępnych miejscach użytkownik ma prawo jedynie wykonywać operacje czytania.
\end{itemize}

\subsection{Funkcje}

Za pomocą funkcji Firebase został zaimplementowany kod serwera serwisu. Jego głównymi zadaniami jest zarządzanie instancjami gier oraz uniemożliwienie prób oszukiwania w czasie rozgrywki przez graczy za pomocą ingerencji w kod źródłowy aplikacji po stronie klienta. \\

Zbiór zdefiniowanych funkcji został uporządkowany w trzy podzbiory. W pierwszym podzbiorze znajdują się wszystkie możliwe do wywołania przez użytkownika funkcje serwera. Drugim podzbiorem jest klasa \emph{GameUtils}, zawierająca statyczne funkcje odpowiedzialne za zarządzanie instancjami gier. Trzecim podzbiorem jest klasa \emph{GameLogic}, zawierająca statyczne funkcje, które odpowiadają za walidację ruchów użytkowników w grze i implementację logiki rozgrywki gry. \\

Charakterystyka funkcji serwera możliwych do wywołania przez użytkownika:
\begin{itemize}
	\item \emph{createGame} - jako paramtry wejściowe przyjmuje ID gracza i jego nazwę, listę nazw graczy zaproszonych do gry oraz czas przeznaczony na wykonanie ruchu w trakcie gry. \\
	Wywołuje ona metodę \emph{createGame} z klasy \emph{GameUtils}. Następnie wyszukuje poszczególnych graczy i informuje ich o zaproszeniu do gry. \\
	Parametrem zwracanym jest ID nowo utworzonej gry.
	\item \emph{searchGame} - jako parametry wejściowe przyjmuje ustawienia gry: liczbę graczy i czas przeznaczony na ruch gracza oraz ID gracza i jego nazwę. \\ 
	Wywołuje funkcję \emph{findGame} z \emph{GameUtils}. Jeśli gra zostanie znaleziona wywoływana jest funkcja \emph{addToGame}. Następnie jeśli gracz zajął ostatnie wolne miejsce w grze, wywoływana jest funkcja \emph{startGame} z \emph{GameUtils}. Jednak jeśli nie znaleziono gry, wywoływana jest funkcja \emph{createGame} z klasy \emph{GameUtils}.	Aby uchronić się przed wyszukiwaniem i modyfikowaniem bazy danych jednocześnie przez kilka wywołań funkcji \emph{searchGame} przez różnych graczy, proces wyszukania gry i zapisu do niej odbywa się poprzez transakcje. \\
	Parametrem wyjściowym jest ID gry.
	\item \emph{addToExistingGame} - jako parametry wejściowe przyjmuje ID gry oraz ID gracza i jego nazwę. \\
	Funkcja szuka instancji gry, a następnie wywołuje \emph{addToGame} z \emph{GameUtils}. Operacje na bazie danych również odbywają się z pomocą transakcji.
	\item \emph{putTiles} - jako parametry wejściowe przyjmuje ID gracza i gry oraz zbiór zbiorów kości znajdujących się na planszy. \\
	Znajduję instancję gry i subkolekcje graczy uczestniczących w niej, a następnie wywołuje metodę \emph{checkTurn} z \emph{GameLogic}. Potem nadaje prawo ruchu kolejnemu graczowi w kolejce. Dalej wywołuje metodę \emph{addNewTiles} z \emph{GameLogic}. Jeśli metoda ta zwróci, że gracz jest zwycięzcą, wskazuje zwycięzcę. Jeśli zwróci, że gracz nie wykonał żadnego ruchu lub próbował oszukiwać, to doda do jego zbioru kości kolejną kość z banku. W przypadku, gdy była to ostatnia kość z banku, to wywołuje metodę \emph{pointTheWinner} z \emph{GameLogic}.
	\item \emph{leftGame} - jako parametry wejściowe przyjmuje ID gracza i gry. \\
	Usuwa gracza z kolejki graczy w grze. Jeśli akurat ten gracz miał prawo ruchu, daje możliwość ruchu następnemu graczowi. \\
\end{itemize}

Charakterystyka funkcji statycznych serwera z klasy \emph{GameUtils}:
\begin{itemize}
	\item \emph{createGame} - tworzy dokument gry w kolekcji \emph{games}. Dodaje założyciela do subkolekcji \emph{playersQueue} oraz tworzy wszystkie możliwe kości w postaci dokumentów i dodaje je do subkolekcji \emph{pool}. \\
	Zwraca ID gry.
	\item \emph{addToGame} - dodaje gracza do istniejącej już gry. \\
	Zwraca ID gry oraz wartość logiczną dotyczącą występowania wolnych miejsc w grze.
	\item \emph{findGame} -  za pomocą parametrów ustawień gry (liczba graczy, czas na ruch) szuka wolnej instancji gry. \\
	Zwraca instancję gry lub null.
	\item \emph{startGame} -  przydziela graczom po 14 kości losowo wybranych z subkolekcji \emph{pool}. Nadaje prawo do wykonania ruchu pierwszego graczowi w subkolekcji \emph{playersQueue}. \\
\end{itemize}

Charakterystyka funkcji statycznych serwera z klasy \emph{GameLogic}:
\begin{itemize}
	\item \emph{checkTurn} - sprawdza, czy dany gracz ma prawo wyłożyć kości.
	\item \emph{addNewTiles} - przeprowadza walidację nowego zbioru kości na planszy. Sprawdza, czy zbiory są poprawnie ułożone, czy występują wszystkie poprzednie kości na planszy, czy nowo położone kości należą do gracza. W przypadku wyłożenia początkowego sprawdza czy gracz wyłożył nowe ułożenia o wartości co najmniej 30 punktów oraz czy poprzednie ułożenie nie zostały zmodyfikowane. Po spełnieniu tych warunków usuwa nowo wyłożone kości z puli gracza i modyfikuje stan planszy. W przypadku wyłożenia początkowego odznacza, że zostało wykonane. \\
	Zwraca informację, czy kości zostały poprawnie dodane lub informację, że gracz zwyciężył w przypadku usunięcia wszystkich kości z jego puli.
	\item \emph{getTileFromPool} - wybiera jedną kość z subkolekcji \emph{pool} i przydziela je danemu graczowi. \\
	Zwraca informację, czy w \emph{pool} znajdują się jeszcze dostępne kości.
	\item \emph{pointTheWinner} -  sumuje wszystkie wartości kości w poszczególnych pulach graczy. Wskazuje zwycięzcę lub zwycięzców w przypadku równości sum. \\
\end{itemize}

\section{Klient}

Warstwa klienta w serwisie napisana we Flutterze jest dostępna jako aplikacja na telefon albo jako strona internetowa. Z uwagi na wieloplatformowość Fluttera kod źródłowy obu wersji klienta jest wspólny z odpowiednimi konfiguracjami i modyfikacjami na poszczególne platformy.

\subsection{Warstwa prezentacji}

W warstwie prezentacji zdefiniowany jest wygląd aplikacji klienta. Warstwa ta składa się z bezstanowych widgetów, które generują interfejs graficzny. Klasy te odpowiadają za odbieranie
komunikatów ze strony użytkownika jak i przekazują lub odbierają komunikaty ze strony logiki aplikacji. Zdarzenia te mogą mieć wpływ na wygląd danego widgeta. Komunikacja pomiędzy poszczególnymi stronami aplikacji jest również zdefiniowana w tej warstwie. \\

Nawigacja pomiędzy stronami odbywa się poprzez dynamiczną nawigacją z wygenerowanymi trasami. Jest to jeden ze sposobów komunikacji we Flutterze, dzięki któremu za cały proces nawigacji odpowiada klasa \emph{app\_router}, a w poszczególnych widgetach podaje się nazwę ścieżki i obiekty do przekazania pomiędzy stronami. Główną zaletą korzystania z tego sposobu jest eliminacja bezpośrednich zależności pomiędzy widgetami. Ponadto zmniejsza się objętość kodu, a sam kod staje się bardziej przejrzysty.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[width=13cm,height=10cm]{img/nawigacja.png}
	\end{center}
	\caption{{\color{dgray}Diagram nawigacji.}} 
	\label{nawigacja}
\end{figure}  

\emph{HomeScreen} jest ekranem startowym aplikacji, od którego zaczyna się każda inna ścieżka. W programie można podążyć dwoma głównymi ścieżkami. Pierwszą ścieżką jest wybranie gry z botem lokalnie na urządzeniu użytkownika bez konieczności połączenia z internetem. Następnie wybraniu ustawień bota i kolejno ustawień gry i przejściu do rozgrywki. Po wyjściu z gry użytkownik wraca do ekranu startowego. Drugą ścieżką jest z kolei zalogowanie się lub utworzenie konta gracza. Następnie użytkownik będzie miał do wyboru sposób rozpoczęcia gry. Jeśli zdecyduje się na utworzenie własnej gry z innymi aktywnymi użytkownikami, przechodzi do strony \emph{ActivePlayersScreen}, a dalej do ustawień gry. Jeśli jednak będzie chciał dołączyć do istniejącej już gry, aplikacja przekierowuje go bezpośrednio do \emph{GameSettingsScreen}. Po przejściu do rozgrywki gracz w każdej chili może opuścić grę. W takim przypadku znajdzie się z powrotem w \emph{GameScreen}. Z którego również może nastąpić wylogowanie się użytkownika i powrót do ekranu startowego. \\ \\ 

Charakterystyka poszczególnych klas w warstwie prezentacji:
\begin{itemize}
	\item \emph{AppRouter} - klasa odpowiadająca za nawigację w aplikacji. Zawiera zdefiniowane ścieżki, które wskazują na poszczególne strony. Jest odpowiedzialna za tworzenie nowego ekranu i dołączanie do niego odpowiednich zależności i przekazywanych parametrów.
	\item \emph{HomeScreen} - klasa zawierająca trzy przyciski kolejno prowadzące do \emph{RegirstrationScreen}, \emph{LoginScreen}, \emph{BotSettingsScreen}. Ekran startowy aplikacji.s
	\item \emph{RegirstrationScreen} - klasa zawierająca formularz z danymi do rejestracji (email, nazwa gracza, hasło, potwierdzenie hasła). Przeprowadza walidację formatu email oraz długości hasła i jego identyczności z potwierdzającym hasłem.
	\item \emph{LoginScreen} - klasa zawierająca formularz z potrzebnymi danymi do zalogowania użytkownika (email, hasło).
	\item \emph{BotSettingsScreen} - klasa zawierająca dwa przyciski, odpowiadające za wybrany poziom bota. Przekierowują one do ekranu \emph{GameSettings} z argumentami \emph{playerId} oraz \emph{serverType}, co w przypadku gry z botem będzie równoznacze z numerem ID gracza \emph{0} oraz typ serwera \emph{basicBot}, \emph{advancedBot}.
	\item \emph{GameScreen} - klasa zawierająca dwa przyciski, które definiują sposób dołączenia do rozgrywki. Prowadzą one do stron \emph{ActivePlayersScreen}, \emph{GameSettingsScreen} i jako parametr przekazują ID gracza. Ponadto, gdy użytkownik chce powrócić do wcześniejszej strony zostanie wyświetlone okno dialogowe, wymuszające potwierdzenie decyzji, gdyż wiążę się ona z wylogowaniem użytkownika i powrotem do ekranu startowego. W przypadku, gdy użytkownik zostanie zaproszony do gry przez innego gracza, również zostanie wyświetlone okno dialogowe, w którym gracz będzie mógł przyjąć lub odrzucić zaproszenie.
	\item \emph{ActivePlayersScreen} - składa się z wyszukiwarki, listy aktywnych użytkowników oraz przycisku. Lista aktywnych użytkowników jest sortowana względem wyrazu wpisanego do wyszukiwarki. Użytkownik wybiera z listy graczy, których chce zaprosić do gry. Po kliknięciu w przycisk przechodzi do \emph{GameSettings} z parametrami \emph{playerId} (ID użytkownika), \emph{selectedPlayers} wybrani gracze, \emph{serverType} (nazwę serwera).
	\item \emph{GameSettingsScreen} - klasa zawierająca dwa pola przeznaczone do konfiguracji liczby uczestników i czasu przeznaczonego na ruch gracza oraz przycisk. Po kliknięciu w przycisk ukazuje się obracające kółeczko i napis z liczbą graczy brakujących do rozpoczęcia rozgrywki. Po pojawieniu się wymaganej liczby graczy nastąpi przekierowanie do \emph{GameActionScreen} z parametrami \emph{gameId}, \emph{playerId}, \emph{serverType}.
	\item \emph{GameActionScreen} - klasa obrazująca całą rozgrywkę w grę Rummikub. W górnej części znajduję się panel, na którym widać wszystkich uczestników i ilość pozostałego czasu dla aktualnie grającego gracza oraz przycisk zatwierdzający ruch. W środkowej części znajduje się plansza, na której można umieszczać swoje kości tworząc lub rozbudowując obecnie znajdujące się tam kości. W dolnej części umieszczony jest zbiór kości, które aktualnie posiada gracz. Komunikaty informacyjne o występujących zdarzeniach w czasie rozgrywki są pokazywane w postaci znikających dymków (toasty).
\end{itemize}

\subsection{Warstwa logiki}

W warstwie logiki zdefiniowane są zasady działania aplikacji. Z racji wykorzystanego wzorca projektowego we Flutterze klasy te są w postaci cubitów. Instancje tych klas są tworzone w klasie \emph{AppRouter} i odpowiednio są powiązane z klasami w warstwie prezentacji. Do każdego cubita przypisany jest zbiór klas, które reprezentują poszczególne stany. Klasy stanowe są przekazywane za pomocą strumienia do odpowiednich klas w warstwie prezentacji. \\

Charakterystyka poszczególnych cubitów:
\begin{itemize}
	\item \emph{AuthCubit} -
	\item \emph{GameSettingsCubit} -
	\item \emph{ActivePlayersCubit} -
	\item \emph{GameActionPanelCubit} -
	\item \emph{GameActionBoardCubit} -
	\item \emph{GameActionRackCubit} -
\end{itemize}

\subsection{Warstwa danych}

\subsection{Przepływ zdarzeń}


